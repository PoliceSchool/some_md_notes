## 过期数据

redis是一种内存级数据库，所有数据均放在内存中，内存中的数据可以通过TTL指令获取其状态

* 如果是一个正整数（1,2,3,4...），那么表明这个key剩下可存活时间
* 如果是"-1",那么就是永久有效的数据
* 如果是"-2"，那么表明是**已经过期** 或 被删除的数据  或未定义的数据（这里需要解释一下，已经过期不代表立刻被删除，已经过期的数据还可以在内存中存在一段时间，被删除的数据就已经从内存中删除了）

## 数据删除需要知道的基本点

由于讨论的是数据如何从内存中删除，所以此时关注的焦点是redis中**"已经过期的数据"**

1. redis中数据的存储格式
   * redis中可以通过EXPIRE、EXPIREAT、PEXPIRE、PEXPIREAT这几个命令给key设置一个超时时间
   * redis中一个key会对应一个value，假设现在redis中有一个kv键值对是(name, ititheima)。其实这个"ititheima"在内存中占用着一块内存空间，假设这个"ititheima"占用的这个地址为0x0110。那么如果还设置了"name"所对应的超时时间的话，redis还会存储关于这个"name"的超时时间的相关信息。具体就是开辟一个新的数据结构expires(本质就是一个hashmap)，将前面那个"ititheima"所对应的地址"0x0110"作为一个新的的key值放进expires，并且将这个"0x0110"所对应的value设置为"name"的超时时间。这样遍历的时候就直接根据这个expires来遍历超时时间然后删除对应的"ititheima"即可，因为expires的key值就是"ititheima"的地址。如下图所示。
     ![](/home/jimson/Documents/github/policeschool/some_md_notes/redis/redis数据存储结构图.png)
2. 数据删除需要注意的地方
   * 删除数据是为了减少内存占用，但是过分的减少内存占用有可能导致CPU过分忙碌，导致性能下降，因为花在检索删除无效key的时间过长。操作不当有可能造成内存泄露或者CPU爆满。所以需要在内存占用和CPU占用之间取得平衡点。

## 数据删除策略

1. 定时删除
   * 当为一个key值设置时间之后，会为这个key值创建一个定时器，当过期时间到达时，由定时器立即执行对键的删除操作
   * 优点：节约内存，到时就删除，快速释放掉不必要的内存占用
   * 缺点：CPU压力大，无论此时CPU负载多高，均占用CPU，会影响redis服务器的响应时间和指令吞吐量
   * 总结：用处理器性能换区存储空间（拿时间换空间）
2. 惰性删除
   * 数据到达过期时间，不作处理。等下次访问该数据时：
        每次访问一个key的时候都会调用一个expireIfNeeded函数以确定该key是否过期
     1. 如果未过期，返回数据
     2. 发现已过期，删除，返回不存在
   * 优点：节约CPU性能，发现必须删除的时候才删除
   * 缺点：内存压力很大，出现长期占用内存的数据
   * 总结：用存储空间换取处理器性能（拿时间换空间）
3. 定期删除（折中方案）
   周期性的执行内存清理操作。如下图所示，redis每秒会执行若干轮执行内存清理操作；每轮都需要遍历redis中所有库；遍历每个库的时候从库里面随机抽取W个，从这W个里面淘汰过期的kv（每个库里面都有对应的expires结构，从这个结构里去遍历需要被淘汰的key值）。可以看出有3层for循环，第一层是redis每秒执行若干轮执行内存清理操作，第二层是在每一轮执行内存清理操作的时候去遍历redis中所有的库（默认16个 ），第三层是遍历每个库的时候还需要随机抽取库中的W条kv键值对，从这W个中去选择需要被删除的kv键值对。
   ![](/home/jimson/Documents/github/policeschool/some_md_notes/redis/redis存储空间.png)
   **详细删除过程**
   * Redis启动服务器初始化时，读取配置文件server.hz的值，默认为10
   * 每秒钟执行server.hz次**serverCron()**,也就是上面说的**"redis每秒会执行若干轮执行内存清理操作"**;每轮操作又会调用**databasesCron()**,就是上面说的遍历每一个库；在遍历库的时候会调用**activeExpireCycle()**,就是上面说的随机抽取库中的W条kv键值对，从这W个中去选择需要被删除的kv键值对。
   * 在对某个库，也就是某个expires[*]检测时，随机挑选W个key检测：
     1. 如果key超时，删除key
     2. 如果每一轮中删除的key的数量>W*25%，循环该过程（因为该库过期key值较多，有相当大的可能性存在更多的过期key值，所以需要在当前库下多循环一遍）
     3. 如果每一轮中删除的key的数量<=W*25%，那么就检测下一个库，也即是下一个expires[],0-15循环（因为该库过期key值较少，有相当大的可能性不存在更多的过期key值，所以直接跳到下一个库了）
     4. W取值为配置中的**ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP**属性值
     5. 当某次遍历的时候，当年是在第1个库执行删除操作，但是刚好清理的时间到了，CPU需要处理别的事情了，那么当下次再次进行删除key值的操作时，是直接从第0个开始清理还是接着从上次没处理完的地方开始清理呢？redis选择后者，那么就需要一个变量来记录上次的最后一次清理操作是在哪个库下执行的，用来告诉当前这次清理操作需要从哪个库开始清理，这个变量就是**current_db**
     6. 每次占用CPU时间的25%去清理key，不会出现**定时删除**的极端情况会使得CPU在某一时刻飚满，也不会出现**惰性删除**的极端情况使得内存占用过大而导致内存溢出。这种方法最多占用CPU 25%的时间，同时也能保证内存不会占用过大
4. Redis采用的是**惰性删除**和**定期删除**

## 数据淘汰(数据逐出)

前面的删除操作都建立在key已经过期的情况下，如果redis中的key全都没有过期的情况下怎么办呢？这种情况下没有一个key会被删除，那么就需要**数据淘汰**了

* 检测易失数据（可能会过期的数据集server.db[i].expires)

  1. volatile-lru：挑选最近最少使用的数据淘汰
  2. volatile-lfu：挑选最近使用次数最少的数据淘汰
  3. volatile-ttl：挑选即将要过期的数据淘汰
  4. volatile-random：任意选择数据淘汰

* 检测全库数据（所有数据集server.db[i].dict)

  1. allkeys-lru: 挑选最近最少使用的数据淘汰
  2. allkeys-lfu: 挑选最近使用次数最少的数据淘汰
  3. allkeys-random: 任意选择数据淘汰

* 放弃数据淘汰

  1. no-enviction(驱逐)：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out of Memory）

* redis中的配置文件

  ```shell
  maxmemory-policy  volatile-lru
  ```

以上内容参考链接：https://www.bilibili.com/video/av76235738?from=search&seid=10190615426081428570



## Redis中的LRU实现细节

http://redis.cn/articles/20161114002.html

https://blog.csdn.net/mysqldba23/article/details/68482894

https://blog.csdn.net/WhereIsHeroFrom/article/details/86501571



## 疑问

1. redis不是有内存淘汰机制吗？就是内存容量满了，就要将部分数据从内存中或者写进磁盘中的数据库文件，假设现在采取写进磁盘中的数据库文件这种机制，那么如果一个key "k1"在内存中没有，在redis的数据库文件有，此时如果redis接收到了一个关于"k1"的get请求，那么redis是会返回null还是去磁盘文件找这个"k1"然后返回对应的值呢？
   我的想法（不一定正确）：如果一个key被删了那就是被删了，不管是内存淘汰还是用户自己删的，都不会再内存或者硬盘中存在，redis的容量最大只到内存容量那么大，所以内存容量满了之后那些被淘汰的key是不会写到磁盘去的。
2. 由于内存限制，导致了Redis中只能存储最多1W条的数据信息，如何确保这1w条数据是最热门的数据？
   答：使用SortSet数据结构，比如用户登录时，每登录一个用户，就将SortedSet对应用户ID的score加1
3. 如果一开始使用LRU模式，突然改变配置变成了LFU模式，想象一下Redis对象头的lru字段值会对现有的对象产生什么影响？