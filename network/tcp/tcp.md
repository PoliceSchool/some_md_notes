## 什么是TCP?

TCP, 全名Transmission Control Protocol, 中文名传输控制协议.它是一种面向连接的,可靠的传输层通信协议.

这个协议有两大特点: **面向连接**,  **可靠**

### 面向连接

1. 什么是连接呢?
   比如一根电线,可以将电从发电厂一直传送到家里的电插座上.这根电线就是连接,它可以保证电力可靠的到达千家万户.类比到计算机网络中,你的电脑需要跟其他人的电脑进行通信,比如传送一个"Hello World"字符串,你可以想象成你的电脑跟其他人的电脑有一条连接,你要传送的"Hello World"字符串就顺着这条连接到达了其他人的电脑上,于是你们就可以通过这条连接进行通信.但是计算机网络中没有这样的连接,计算机网络中都是一个一个的节点.那么你要跟你的朋友通信,但是又没有这样的一条连接直接到达你的朋友的电脑上,怎么办呢?TCP帮你建立了连接,让你的数据可以通过TCP建立的连接到达你的朋友的电脑上,然后你们就可以通信了.所以TCP是面向连接的.所以TCP的连接由TCP建立和控制,应用程序就可以简单的认为通过TCP已经建立了一条连接了,接着应用程序就可以通过这条连接进行通信了.

2. 为什么需要面向连接呢?
   因为你跟其他人通信不管通过什么方式,最终都会有一条路径到达目的地.说白了就是你需要一条连接将你和你的目的地连接起来,所以需要一条连接,在这条连接上可以进行可靠的数据传输.

3. TCP如何为通信双方的应用程序提供面向连接的假象呢?

   * 其实计算机网络中没有所谓的这么一个物理连接的概念,也不可能有,因为计算机网络中都是单独的网络节点,而且节点的数量很多,不可能为每两个节点建立一条物理连接.这是前提1.
   * 现实情况是,一段应用程序的数据可能被TCP切割成多个数据包并且发送到网络上,由于网络上都是单独的网络节点并且这些节点都可以自主地将数据传送到它所认为最合适的下一跳节点.所以即使是发送者和接收者都是一样的一些数据包,它们经过的路径有可能是不一样的,这就导致了数据的失序问题.这便是TCP要解决的问题.因为如果是一条真实的物理连接,数据都是以先后顺序到达的,没有失序问题.TCP既然是面向连接的,那么就应该解决数据失序的问题.当然TCP解决的不仅仅是这个问题.这是前提2.
   * 综上,因为不可能有物理连接,所以TCP建立的是虚拟连接,又因为这个虚拟连接需要解决数据在网络传输中所带来的一系列问题,并且为应用程序提供一个面向连接进行数据传输的假象.**所以TCP在通信双方的电脑上各自建立一些基础数据并维护这些基础数据,比如通信的目的地址,端口号,数据的顺序号,超时时间,定时器等等.在将数据包发送至网络时要带上这些基础数据,以便接受者通过这些基础数据重新组织数据.通过这些方式来模拟一条连接.**

4. 通信双方如何如何建立和销毁TCP连接呢?

   * 建立TCP连接的过程其实就是在通信双方开辟资源,建立一些基本信息的过程.以保证通信双方都确保对方已经准备好了跟自己通信.
   * [三次握手](./tcp_3_way_hand_shake_process.md)
   * [四次分手](./tcp_connection_termination.md)
   * 三次握手引发的问题:DDos攻击

5. 如何看到TCP维护的基础数据呢?

   ```shell
   ## 要想看到TCP相关的基础数据,得先要创建TCP连接, 创建TCP连接方式有很多种,可以自己写个网络服务器去连一下百度
   ## 这里就用linux的命令创建TCP连接, 大致意思就是建立本机到百度的80端口的TCP连接,
   ## 建立完TCP连接之后linux会产生一个socket,这个socket就是用来跟百度通信的,百度来数据或者
   ## 往百度发送数据都要通过这个socket来实现,又因为linux中一切皆对象的概念,所以socket也是一个文件
   ## 下面的命令是给这个socket文件关联一个文件描述符"8", 此后跟文件描述符"8"进行读写就相当于对socket进行读写.
   exec 8<> /dev/tcp/www.baidu.com/80
   ```

   ```shell
   ##上面的命令回车之后,会在当前进程里面生成一个文件描述符为"8"的文件
   ## 下面命令中的"$$"代表当前进程
   ll /proc/$$/fd
   ## 结果如下图,记住红色字体中的数字"902141",后续会用到它来追踪到相关的TCP连接
   ```

   ![](/home/jimson/Documents/github/policeschool/some_md_notes/network/tcp/查看文件描述符命令.png)

   ```shell
   ## 要想知道TCP连接的基础数据,主要使用下面这个命令就能知道了
   ## 大意就是打印出当前建立的所有TCP连接的相关信息, 然后可以在屏幕显示出来的所有TCP连接中根据上面的
   ## 红色数字找到对应的那条TCP连接
   cat /proc/$$/tcp
   ## 或者嫌麻烦直接用下面这个命令, 可以直接找到对应的那条TCP连接,顺带将title也打印出来
   cat /proc/net/tcp | grep -E '902141 | sl'
   ## 具体关于打印出来关于TCP的各项参数参考以下的链接
   https://blog.csdn.net/justlinux2010/article/details/21028797
   https://www.jianshu.com/p/42f174ba2a1a
   ```

 6. TCP抓包

      ```shell
      ## 使用以下命令对80端口进行监听, enp34s0是我的网卡,不同机器上的网卡不一样
      sudo tcpdump -nn -i enp34s0 port 80
      ## 结果如下图
      ```

      ![](/home/jimson/Documents/github/policeschool/some_md_notes/network/tcp/开启80端口监听.png)

      ```shell
      ## 新开一个命令行窗口,然后访问百度
      curl www.baidu.com
      ## 执行完上面的命令之后再切回监听80端口的命令行窗口,结果如下图
      ## 在最开始进行了三次握手,在最后又进行了四次分手,中间还进行了数据传输,可以看到每个数据的传输都有syn,win,ack这些数据.
      ```

      ![](/home/jimson/Documents/github/policeschool/some_md_notes/network/tcp/80端口监听到信息.png)

   ### 建立连接时涉及到的IP层协议

   TCP只是负责连接的建立和控制,也就是维护TCP包在通信双方的状态.但是具体这些TCP包如何到达对方的主机,如何路由到对方的主机,那就是IP层的事情了.每一层有每一层的职责,TCP负责通信双方的可靠性传输,IP负责将TCP的数据路由到对方的主机.

首先,TCP会将自己产生的包交给IP层.IP层再将TCP包封装多一层,为什么要添加多一层呢?因为要加上下一跳的地址,因为计算机网络中数据是一跳一跳的被传送到目的主机的,而不是直接到达的.所以IP层这一层所要做的事就是检查当前数据包的IP地址应当走哪个出口发送出去.接下来看看IP是如何做的.

```shell
## 使用以下命令查看网路路由表
route -n
## 此命令用于查看当前主机上的网路路由表.比如TCP传了一个包到IP层,IP层要将这个包转到下一跳,假设TCP包的IP地址为183.232.231.172,IP层按照下图的路由表进行匹配.
## 匹配规则是,将IP地址183.232.231.172依次跟下图中的Genmask(掩码)做与运算,得到的结果再跟Destination比对,如果匹配的话,说明当前这个包应当从当前在路由表所匹配到那条纪录的Gateway发送出去.
## 在下图的路由表中,183.232.231.172只会与第一条记录匹配成功,因为183.232.231.172与第一条记录的Genmask做与运算后得到的结果为0.0.0.0,这个值跟第一条记录的Destination的值一样,即匹配成功,所以当前数据包就要走第一条记录的Gateway(网关).
## 也就是当前这个数据包的下一跳地址将会是192.168.0.1这台网关设备.
```

![](/home/jimson/Documents/github/policeschool/some_md_notes/network/tcp/查看网络路由表.png)

```shell
## 至此,可以知道一个数据包到达目的地需要两个地址,一个是目的主机地址,另一个是下一跳地址,目的主机是一个ip地址,而下一跳地址则是一个mac地址.上面说过IP层会将TCP包再包一层,而所谓包一层就是将下一跳的mac地址等信息跟TCP包一起组成一个IP包.然后这个IP包就可以传送给下一跳了.下一跳接收到这个IP包拆开外层的包裹可以得到TCP包所对应的目的地址,下一跳再根据TCP的目的地址再得到下一跳的mac地址,再次进行封装后发给下一跳.
## 那么在网络路由表中得到的地址是一个IP地址,如何根据这个IP地址得到这台网关设备对应的MAC地址呢?
## 借助ARP协议即可,使用下面的命令可以看到arp列表
arp -a
## 结果如下图
```

![](/home/jimson/Documents/github/policeschool/some_md_notes/network/tcp/arp列表查看命令.png)

### TCP总的执行流程

1. 应用层想要发送数据, 先要传输层建立连接,应用层先阻塞着
2. 传输层接到应用层建立连接的请求,准备建立握手包跟目的地址建立连接,然后将握手包传给网络层
3. 网络层接到传输层的包先去路由表查找目的地址对应的网关地址
4. 网络层根据网关地址要找到对应的MAC地址,如果有直接返回对应的MAC地址,如果没有启动ARP协议得到网关的MAC地址.
5. 于是网络层就能得到下一跳的MAC地址,就能发送握手包了
6. 当TCP的三次握手成功后,将会建立连接,然后创建相对应的基础数据以及开辟资源
7. 应用层开始发送数据
8. 传输层得到应用层的数据会切割数据,分成多个包,然后再发送给网络层,网络层再发送至目的地址.

以上内容的参考连接:https://www.bilibili.com/video/av93120032



### TCP的可靠性

https://www.cnblogs.com/yichengming/p/11452999.html

TCP协议传输的特点主要就是面向字节流、传输可靠、面向连接。

TCP保证数据可靠传输的方式主要有以下六点：校验和、确认应答与序列号、超时重传、连接管理、流量控制、拥塞控制。

1、校验和

在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。发送方在发送数据之前计算校验和，并进行校验和的填充。接收方收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。

注意：如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是如果接收方比对校验和与发送方一致，数据不一定传输成功。

2、确认应答与序列号

序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。

确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。

序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。

3、超时重传

简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接受到ACK报文，那么对刚才发送的数据进行重新发送。由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待时间）是动态计算的。

4、连接管理

连接管理就是三次握手和四次挥手的过程，保证可靠的连接，是保证可靠性的前提。

5、流量控制

接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传。而TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。

6、拥塞控制

TCP通过维护一个拥塞窗口来进行拥塞控制。网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据发送出去。网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数。